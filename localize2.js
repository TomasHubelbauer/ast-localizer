const fs = require('fs-extra');
const klaw = require('klaw');
const ts = require('typescript');
const sourcemap = require('source-map');

void async function () {
  const locale = process.argv[2];
  if (!locale) {
    return;
  }

  const resources = await fs.readJson('res/' + locale + '.json');
  for await (const item of klaw('build')) {
    // Skip directories
    if (!item.stats.isFile()) {
      continue;
    }

    // Ignore non-code files
    if (!item.path.endsWith('.js')) {
      continue;
    }

    // Consider only mapped files
    if (!(await fs.pathExists(item.path + '.map'))) {
      continue;
    }

    const map = await new sourcemap.SourceMapConsumer(await fs.readJson(item.path + '.map'));

    // Pull out string literals in the target files
    const targetPath = item.path;
    const targetText = String(await fs.readFile(targetPath));
    const targetFile = ts.createSourceFile(
      targetPath,
      targetText,
      ts.ScriptTarget.ES5, // tsconfig.json
      true
    );
    const targetNodes = [targetFile];
    const targetTexts = [];
    do {
      const node = targetNodes.shift();
      targetNodes.unshift(...node.getChildren());
      if (node.kind === ts.SyntaxKind.StringLiteral) {
        const text = node.text;
        const targetPosition = targetFile.getLineAndCharacterOfPosition(node.pos);
        const targetLine = targetPosition.line + 1;
        const targetCharacter = targetPosition.character + 1;
        const sourcePosition = map.originalPositionFor({ line: targetLine, column: targetCharacter });
        const sourceLine = sourcePosition.line + 1;
        const sourceCharacter = sourcePosition.column + 1;
        const sourcePath = sourcePosition.source;

        // Ignore string literals generated by CRA
        if (sourcePath === null || sourcePath === '../webpack/bootstrap' || sourcePath.startsWith('../node_modules')) {
          continue;
        }

        targetTexts.push({ text, targetPath, targetLine, targetCharacter, sourcePath, sourceLine, sourceCharacter });
      }
    } while (targetNodes.length > 0);

    // TODO: For each found text, group them by the source file, then for each
    // of those source files, pull their string literals. If the two sets of
    // string literals match, consider the heuristic condition met. Replace the
    // string literals in the target by the localized versions from the resource
    // files. Eventually replace not the node text, but it itself with a
    // function call one which fetches the localized text at runtime to be able
    // to hot-swap the localization resources at runtime.
    for (const text of targetTexts) {
      console.log(text);
    }
  }
}()
