# CRA AST Localize

This is a project where I attempt to see if replacing string literals with their
localized versions (or a localizer function invocations) could feasibly be done
by running a `postbuild` step which uses the TypeScript compiler API to pull out
the string literals and replace/augment them.

`npm build` or `npm run postbuild` with an existing `build` directory

## Design

Initially, I was going to do this:

- [x] Scaffold a normal CRA project
- [x] Add a post-build script which reads the AST of the emitted files
- [x] Use source maps to find code corresponding to user files and avoid code from dependencies
- [x] Use context heuristics to kick out invalid literals (identifiers, JSX/TSX, â€¦)
- [ ] Replace string literals with a call to a localizer function (like `localize('')`)
- [ ] Warn on localization keys which are not contained within the localization files
- [ ] Append the localizer function implementation and the localization resources
- [ ] Observe a localized application without the need to clutter the code with resource lookup

However, I have found that the map generated by Babel and used by WebPack and so
CRA does not contain enough information to make it work. For string literals, it
maps any position with them to their start and for string literals used as React
children, it maps them to the React function calls, not the string literals used
as arguments to those calls.

See https://github.com/TomasHubelbauer/babel-sourcemap for more information.

Instead, I'm now trying to make the following work:

- [x] Pull out string literals from the source using TSC
- [ ] Pull out string literals from the target using TSC
- [x] Ignore string literals in target not in source (`use string` etc.)
- [ ] Validate the remaining sets of literals match in count and order
- [ ] Replace the string literals in the target with corresponding resource strings

I am prototyping this in `index.js`:

- Go to `cra-sample` and run `npm install` and `npm run build`
- Copy the `build` into `coverage` to not change strings inline in development
  - Use the name `coverage` because it is ignored in the CRA scaffold
  - Do this after each run so they two directories start off the same
- Run `node .` and compare files in `build` with files in `build-copy`

## To-Do

### Add a non-CRA version hosted on GitHub Pages

With JS/TS source input on one side and compiled output on the other for a demo

Rename to just AST localizer then, it should be more generic than just React.
We will need to add logic for recognizing minimized files with source maps in
case of React etc. and normal sources files further unprocessed so that we do
the original context lookup where it makes sense or just go with the source file
where there is no mapping to take into an account.

To make this work with non-CRA, it will probably need to be configurable to say
which paths to ignore (node modules, WebPack bootstrap, `null` etc.).

### Replace the hardcoded text replacement with a localizer function invocation

Add two modes to work in:

One where the text gets replace with a localizer version and the localized
version with the hardcoded localized strings gets saved with a locale suffix.
This mode is useful for translating app to another locale statically without any
runtime localization support.

Another where the string literals get replaced with a call to a localizer
function so that at runtime, a locale can be selected and on next render, the
strings are pulled from the new locale.

### Finalize the alternative solution - `localize2.js`

This should be immune to the Babel sourcemap problem described below and allow
me to continue.

### Follow up on the problem with WebPack/Babel source map string literal info

https://github.com/TomasHubelbauer/babel-sourcemap

I seem to remember this was needed for this project to be able to be finished.

### Fix the broken shift trackers in `index.js` and finalize the implementation

This new implementation works without the source map, but replacing the strings
and keeping track of the differences in coordinates due to the changes compared
to the original is broken.
